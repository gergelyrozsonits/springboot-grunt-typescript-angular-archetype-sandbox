## Archetype
The project serves as an archetype sandbox. To generate an archetype from it please use the following command:
```
mvn archetype:create-from-project -Darchetype.properties=./archetype.properties
```
Before the archetype can be used it needs to be installed with the following command:
```
mvn install -f target/generated-sources/archetype/pom.xml
```
As a last step to generate a project from it just execute the following command (Please note: the project version should follow the ```MAJOR.MINOR.PATCH``` pattern according to https://docs.npmjs.com/files/package.json#version, as ```package.json``` is using the same placeholder as the ```pom.xml``` files):
```
mvn archetype:generate -DarchetypeGroupId=com.pub4us -DarchetypeArtifactId=springboot-grunt-typescript-angular2-archetype-sandbox -DarchetypeVersion=0.0.1-SNAPSHOT
```
## Backend
The project is using a regular Spring Boot based back-end and [Thymeleaf](http://www.thymeleaf.org/) as a templating framework. Spring Boot is dealing with all the configuration tasks via auto-configurations, therefore beside adding *org.springframework.boot:spring-boot-starter-thymeleaf* as a dependency nothing else needs to be done. The templates can be found in ```/src/main/resources/templates/``` directory.
## Frontend
### Fundaments
Even if the project is using Maven as a project management tool, in the frontend layer it doesn't seems to be a good idea to use only Maven plugins to cover all of the UI related operations. However there are such great java-based toolchains like [wro4j](https://alexo.github.io/wro4j/), as not all the operations can be covered properly with these tools at this moment (e.g.: creating source map files for typescripts) the project is following a different approach, namely to rely the regular node-based tools do their job in the UI layer but bound these operations to certain Maven phases via the *com.github.eirslett:frontend-maven-plugin* plugin.
### Maven plugin
Even if com.github.eirslett:frontend-maven-plugin plugin is relying on node based technologies, it does not required to have a standalon node installation on the build system as the plugin is able to download a node/npm during build time. As node is responsible for managing the dependencies on UI side, as a next step the the plugin needs to execute the ```npm install``` command to download the project (UI) dependencies based on ```package.json```. The installation initialize the dependencies and creates the ```node_modules``` directory (if needed) in the project root directory. As the ```package.json``` has a ```devDependencies``` section, the required tools (e.g.: Grunt, Karma, Jasmine, Typescript) will be downloaded as well. After the initialization the control will be given to Grunt to build the UI resources and run the tests (in different phases).
### Tools
Before we would dive into details in the configuration, a high level overview of the tools/frameworks is necessary:
- **grunt** act as the main task runner of the project. Via com.github.eirslett:frontend-maven-plugin each registered tasks can be attached to certain Maven build phases. The project is using two registered aliases: one for the build and one for the testing.
- **systemjs**/**karma-systemjs** is a dynamic module loader and it's corresponding Karam plugin to resolves typescript imports, used by the typescripts (during testing as well).
- **grunt-ts** is a typescript compiler plugin for grunt. Via the plugin the compilation can be invoked by grunt directly, however the main configuration of typescript compiler is in ```./tsconfig.json```.
- **grunt-contrib-copy** is a plugin to copy files the same way as Maven's resource plugin.
- **load-grunt-config** is an extension for grunt, with loading load-grunt-config, the plugin makes it possible to separate the task configurations from the main config file. Each task config needs to have it's own config file under ```./grunt``` folder.
- **karma**/**grunt-karma** is a test runner framework with it's corresponding grunt plugin is involved during the test execution
- **jasmin**/**karma-jasmine** is a testing framework (like junit) and it's corresponding Karam plugin used by the project for unit testing in the UI layer
- **phantomjs**/**karma-phantomjs-launcher** is a headless webkit browser, where the tests can be executed via its Karam luncher plugin (Chrome can be used as well via **karma-chrome-launcher**).
### Overview
As it was described earlier Grunt is connected to Maven in two phases: ```generate-sources``` (or build) and ```test```. Each phase has it's own alias task in Grunt config. In ```generate-sources``` phase the typescript compiler will be called to compile the .ts source/test files, then the compiled files will be copied to the necessary directory. The dependencies in ```node_module``` directory, the original .ts files (for source mapping) and the system.conf.js file (see it later) needs to be packaged as well but this will be done by Maven's resource plugin, so no further interaction is necessary during this phase.
The .ts compiler is also part of the test task as source/test files needs to be compiled in this case as well (and therefore no further compilation related plugin is needed for Karam), but in this case the compiled source and test files will be stored in ```target/test-resources/static```. As the root directories (```src/main/ts/``` and ```src/test/ts/```) are truncated, both the content of the source and test directories will be merged together (please note: files with the same name + path under source and test directory is not supported). With having the dependencies and the target files, Karma now is able to deploy the server for testing, to start the browser and to execute the tests.
Only one component is still missing which is the dynamic module loader: systemjs' main goal is to resolve the import in the compiled typescript files based on a path mapping (basically it is a mapping between the references and it's physical location). The primary configuration file for systemjs is ```system.conf.js```. As the de facto module loader for the project is systemjs it needs to be configured for Karam as well.
### Typescript compiler
Even if the process is controlled by grunt-ts, under the hood there is an embedded typescript compiler. The main configuration entry for tsc is ```tsconfig.json```. Beside the location of the .ts files and the output directory there are a bunch of other configuration entries in this file:
- **target** is the format of the output file, however it's highly recommended to stick with ```es5``` based on the browser support for now: http://kangax.github.io/compat-table/es5/
- **module** is the module loader system, in our case systemjs
- **moduleResolution** is module resolution strategy, as a de facto standard ``node`` is suggested to be used
- **sourceMap**/**mapRoot** flag indicates whether the mapping file between the .ts and the generated .js file needs to be created or not. The mapRoot property shows the path between the two files.
- **rootDir**/**rootDirs**/**paths**/**baseUrl** properties are necessary because of the separated source/test root directories. However typescript is able to link dependencies from different root directory together with the helping of a wildcard mapping in the paths configuration without a proper baseUrl, the context relative module resolution (e.g.: refering to a module with ```dummy/dummy-service``` reference where the module is e.g.: under the ```/src/main/ts/dummy/``` directory) wouldn't be possible. Unfortunately this configuration is not supported by grunt-ts therefore the passThrough option needs to be set to true and the baseUrl needs to be added as an additionalFlags. For more information see: https://github.com/TypeStrong/grunt-ts/issues/339.
### Karma
Karma is connected to Grunt via grunt-karma plugin and it is responsible for unit test execution in the UI layer. Karma is able to deploy a web server with the given test files (+dependencies), to start a browser session (or more, but the related plugins needs to be installed) and to execute tests (in our case Jasmine tests, via karma-jasmine plugin) in the given browser. In case of PhantomJs not even an installed browser instance is required, therefore Karma + PhantomJS looks a perfect combination for build time integration (Beside PhantomJS via [Ghostdriver](https://github.com/detro/ghostdriver) can be used in the back-end layer as well).
As Systemjs is used for module loading, Karma needs to be configured according to this (including karma-systemjs plugin what needs to be installed as well). For more information about the configuration please see: https://github.com/rolaveric/karma-systemjs however there are a few things what i would like to highlight about the config:
- **configFile**: karma-systemjs plugin let us use the main systemjs configuration (```system.conf.js```). The remaining configuration can be defined in ```karma.conf.js``` as configuration entries will be merged together.
- **includeFiles**: the listed files will be imported a simmilar way as a ```script``` tag. This is neccessary for us for certain dependencies (```zone```, ```reflect```). Also as PhantomJs does does not support [ES6 Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) therefore ```es6-shim.js``` is also added to solve this problem (even if it's not required e.g.: for Chrome).
- **testFileSuffix**: even if tests and source files are separated from each other, during testing the content of the test/src directories needs to be combined (see this later in Resources section) as - even if the root directory would be different for test/source files - the context relative references should be applied on both source and test references as well (e.g.: if ```/src/test/ts/somedir/somescript.spec.js``` has an import of ```/src/main/ts/somedir/somescript.js``` then the context relative path should be ```somedir/somescript.js``` both in the test modules and the source modules as well). Therefore the project does not support files with same path + name under different typescript root directories. In order to be able to separate the test files from the source files - the same way as the regular ui frameworks suggested - the ```.spec.js``` postfix will be used for tests. These postfix needs to be defined for systemjs as well.
- **config.paths**: Even if the root config file has it's own mapping, according to the karma-systemjs docs a few other dependencies are also required (e.g.: ```traceur.js```, ```system-polyfills.js```, ```es6-module-loader.js```). Beside these dependencies the most important part of this path mapping is the last line:
```'*': 'target/test-resources/static/*'```
As Karma does not support dedicated path mapping for certain directories (e.g.: to map everything under ```target/test-resources/static/``` to ```http://<HOST>:<PORT>/``` URL), the src/test files would be available under ```target/test-resources/static/``` mapping (again, see this later under Resources section). With having this line as a last path mapping (it needs to be the last due to the whildcard mapping) in systemjs configuration if no other mapping can be applied for a certain reference (in our case all project references falls into this group) then ```target/test-resources/static/``` mapping will be used and in this way systemjs will try to use the ```target/test-resources/static/<CONTEXT_RELATIVE_PATH>``` url to download the script.
### Jasmine
Jasmin act as a testing framework. As all the tests are written in typescript, beside Jasmine, its types needs to be installed as well (beside the module, ```tsconfig.json``` file needs to be configured according to this as well). The tests are compiled with the source during build, therefore no further transformation is required to execute the tests (by Karma).
### Resources
Even if it's possible to define the output directory for the compiler, the compiler is not designed to play with the directory structure, which is necessary in our case as with the current project structure, the tests are stored separately from the source code. To utilize m2e's change support, the compiled .js files should be stored under ```target/classes/``` directory. As the project's directory structure will not be changed by the compiler, the test/src files will be separated by the root directories in the output directory as well. Even if a Spring's ResourceHandlerRegistry would let us to hide this structure, it wouldn't be a good practice to spare this structure in the packaged .jar as well. To avoid this situation grunt-contrib-copy plugin can be used to copy the source files from the default output directory to ```target/classes/static```. Even if now the files would under the proper directory and therefore everything will be available on the classpath, the ```/static``` directory needs to be exposed as a web resource, so Spring needs to be configured according to this in the following way (the dependencies under ```node_module``` needs to be exposed as well):
```
registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/");
registry.addResourceHandler("/node_modules/**").addResourceLocations("classpath:/node_modules/");
```
During the testing, the situation is even more complex: as Karma is not able to map path to directories directly, therefore the content of the src/test root directories needs to be combined under a common directory (without spearing the root directories). On the project the ```target/test-resources/static/``` directory will be used for this purpose. This needs to be done by grunt-contrib-copy plugin as well.
### M2E integration
As the compiled typescripts, the mapping files and the original source files are moved under ```target/classes/``` directory, there is no need to add grunt-contrib-watch plugin in order to support change detection. If Eclipse's *Build Automatically* feature is turned on, the compiled typescript files will be replaced on the fly after save (however the typescript compiler might require a bit more time to build the changes).
### Other tools
However it does not require to have node, npm and grunt installed to the dev machine it's highly recommended, mainly to access such commands like:
```javascript
npm search <MODULE> // Search for a js module
npm install <MODULE> --save // Install a specific module and add it the the package.json's dependency section
npm install <MODULE> --save-dev // Install a specific module and add it the the package.json's devDependency section
npm install // Download all dependencies for the projects (```node_module``` directory)
grunt build // Trigger typescript building task
grunt test // Execute Karama tests (also triggers the typescript compilation task)
```